; vim:ft=masm

STACK SEGMENT PARA STACK
	DB 64 DUP (' ')
STACK ENDS

DATA SEGMENT PARA 'DATA'
	WINDOW_WIDTH DW 320
	WINDOW_HEIGHT DW 200
	WINDOW_PADDING DW 6

	BALL_X DW 158
	BALL_Y DW 98
	BALL_SIZE DW 04h

	ORIGINAL_BALL_X DW 158 ; WINDOW_WIDTH	/ 2 - BALL_SIZE / 2
	ORIGINAL_BALL_Y DW 98	; WINDOW_HEIGHT / 2 - BALL_SIZE / 2

	BALL_X_VELOCITY DW 05h
	BALL_Y_VELOCITY DW 02h

	LEFT_PADDLE_X DW 0Ah
	LEFT_PADDLE_Y DW 6
	LEFT_PADDLE_POINTS DB 0
	LEFT_PADDLE_TEXT_POINTS DB '0', '$'

	RIGHT_PADDLE_X DW 130h
	RIGHT_PADDLE_Y DW 6
	RIGHT_PADDLE_POINTS DB 0
	RIGHT_PADDLE_TEXT_POINTS DB '0', '$'

	PADDLE_WIDTH DW 05h
	PADDLE_HEIGHT DW 1Fh
	PADDLE_VELOCITY DW 05h

	TIME_AUX DB 0
	GAME_ACTIVE DB 1   ; bool
	EXITING_GAME DB 0  ; bool
	CURRENT_SCENE DB 0 ; 0 - main; 1 - game
	AI_CONTROLLED DB 0 ; bool

	GAME_OVER_TITLE DB 'GAME OVER', '$'
	GAME_OVER_WINNER DB 'Player 0 won', '$'
	GAME_OVER_PLAY_AGAIN DB 'Press R to play again', '$'
	GAME_OVER_GO_MAIN_MENU DB 'Press E to exit to main menu', '$'
	WINNER_INDEX DB 0

	MAIN_MENU_TITLE DB 'MAIN MENU', '$'
	MAIN_MENU_SINGLEPLAYER DB 'SINGLEPLAYER - S KEY', '$'
	MAIN_MENU_MULTIPLAYER DB 'MULTIPLAYER - M KEY', '$'
	MAIN_MENU_EXIT DB 'EXIT GAME - E KEY', '$'

	; DB 8 bits
	; DW 16 bits
DATA ENDS

CODE SEGMENT PARA 'CODE'

	MAIN PROC FAR
		ASSUME CS:CODE, DS:DATA, SS:STACK
		PUSH DS
		SUB AX, AX
		PUSH AX
		MOV AX, DATA
		MOV DS, AX
		POP AX
		POP AX

		; set video mode
		; https://stanislavs.org/helppc/int_10-0.html
		MOV AH, 00h
		MOV AL, 0Dh ; mode
		INT 10h

		; set background color
		MOV AH, 0Bh
		MOV BH, 00h
		MOV BL, 00h ; https://en.wikipedia.org/wiki/BIOS_color_attributes
		INT 10h

		CHECK_TIME:
			CMP EXITING_GAME, 01h
			JE START_EXIT

			CMP CURRENT_SCENE, 00h
			JE SHOW_MAIN_MENU

			CMP GAME_ACTIVE, 00h
			JE SHOW_GAME_OVER

			MOV AH, 2Ch
			INT 21h

			CMP DL, TIME_AUX
			JE CHECK_TIME

			MOV TIME_AUX, DL

		CALL CLEAR_SCREEN
		CALL MOVE_BALL
		CALL DRAW_BALL

		CALL MOVE_PADDLES
		CALL DRAW_PADDLES

		CALL DRAW_UI

		JMP CHECK_TIME

		SHOW_GAME_OVER:
			CALL DRAW_GAME_OVER
			JMP CHECK_TIME

		SHOW_MAIN_MENU:
			CALL DRAW_MAIN_MENU
			JMP CHECK_TIME

		START_EXIT:
			CALL CONCLUDE_EXIT_GAME

		RET
	MAIN ENDP

	RESET_BALL_POSITION PROC NEAR
		MOV AX, ORIGINAL_BALL_X
		MOV BALL_X, AX

		MOV AX, ORIGINAL_BALL_Y
		MOV BALL_Y, AX

		RET
	RESET_BALL_POSITION ENDP

	MOVE_BALL PROC NEAR
		; move ball's x
		MOV AX, BALL_X_VELOCITY
		ADD BALL_X, AX

		; BALL_X < WINDOW_PADDING
		MOV AX, WINDOW_PADDING
		CMP BALL_X, AX
		JL WIN_RPADDLE

		; BALL_X > WINDOW_WIDTH - BALL_SIZE - WINDOW_PADDING
		MOV AX, WINDOW_WIDTH
		SUB AX, BALL_SIZE
		SUB AX, WINDOW_PADDING
		CMP BALL_X, AX
		JG WIN_LPADDLE
		JMP MOVE_BALL_Y

		WIN_LPADDLE:
			INC LEFT_PADDLE_POINTS
			CALL RESET_BALL_POSITION
			CALL UPDATE_LPADDLE_POINTS_TEXT

			CMP LEFT_PADDLE_POINTS, 05h
			JE GAME_OVER

			MOV WINNER_INDEX, 01h
			RET

		WIN_RPADDLE:
			INC RIGHT_PADDLE_POINTS
			CALL RESET_BALL_POSITION
			CALL UPDATE_RPADDLE_POINTS_TEXT

			CMP RIGHT_PADDLE_POINTS, 05h
			JE GAME_OVER

			MOV WINNER_INDEX, 02h
			RET

		GAME_OVER:
			MOV LEFT_PADDLE_POINTS, 00h
			MOV RIGHT_PADDLE_POINTS, 00h

			CALL UPDATE_LPADDLE_POINTS_TEXT
			CALL UPDATE_RPADDLE_POINTS_TEXT

			MOV GAME_ACTIVE, 00h
			RET

		; move ball's y
		MOVE_BALL_Y:
			MOV AX, BALL_Y_VELOCITY
			ADD BALL_Y, AX

		; BALL_Y < 0
		CMP BALL_Y, 0
		JL REACH_Y

		; BALL_Y > WINDOW_HEIGHT - BALL_SIZE
		MOV AX, WINDOW_HEIGHT
		SUB AX, BALL_SIZE
		CMP BALL_Y, AX
		JG REACH_Y

		; Check if the ball is colliding with the right paddle
		MOV AX, BALL_X
		ADD AX, BALL_SIZE
		CMP AX, RIGHT_PADDLE_X
		JNG CHECK_LPADDLE

		MOV AX, RIGHT_PADDLE_X
		ADD AX, PADDLE_WIDTH
		CMP BALL_X, AX
		JNL CHECK_LPADDLE

		MOV AX, BALL_Y
		ADD AX, BALL_SIZE
		CMP AX, RIGHT_PADDLE_Y
		JNG CHECK_LPADDLE

		MOV AX, RIGHT_PADDLE_Y
		ADD AX, PADDLE_HEIGHT
		CMP BALL_Y, AX
		JNL CHECK_LPADDLE

		NEG BALL_X_VELOCITY
		RET

		CHECK_LPADDLE:
			MOV AX, BALL_X
			ADD AX, BALL_SIZE
			CMP AX, LEFT_PADDLE_X
			JNG EXIT_COLLISIONS

			MOV AX, LEFT_PADDLE_X
			ADD AX, PADDLE_WIDTH
			CMP BALL_X, AX
			JNL EXIT_COLLISIONS

			MOV AX, BALL_Y
			ADD AX, BALL_SIZE
			CMP AX, LEFT_PADDLE_Y
			JNG EXIT_COLLISIONS

			MOV AX, LEFT_PADDLE_Y
			ADD AX, PADDLE_HEIGHT
			CMP BALL_Y, AX
			JNL EXIT_COLLISIONS

			NEG BALL_X_VELOCITY

		EXIT_COLLISIONS:
		RET

		REACH_Y:
			MOV BALL_Y, AX
			NEG BALL_Y_VELOCITY
			RET
	MOVE_BALL ENDP

	MOVE_PADDLES PROC NEAR
		; https://www.stanislavs.org/helppc/int_16.html
		; https://www.asciitable.com

		; check key press
		MOV AH, 01h
		INT 16h

		JNZ DONE
			CMP AI_CONTROLLED, 01h
			JE CONTROL_BY_AI

			; "JZ cannot jump too far" as far as I understood.
			; https://stackoverflow.com/questions/39427980/relative-jump-out-of-range-by
			JMP EXIT_PADDLES_MOVEMENT
		DONE:

		; key pressed key : AL
		MOV AH, 00h
		INT 16h

		CMP AL, 77h ; w
		JE MOVE_LPADDLE_UP
		CMP AL, 57h ; W
		JE MOVE_LPADDLE_UP

		CMP AL, 73h ; s
		JE MOVE_LPADDLE_DOWN
		CMP AL, 53h ; S
		JE MOVE_LPADDLE_DOWN

		CMP AI_CONTROLLED, 01h
		JNE CHECK_RPADDLE_MOVEMENT

		JMP EXIT_PADDLES_MOVEMENT

		CHECK_RPADDLE_MOVEMENT:
			CMP AL, 6Fh ; o
			JE MOVE_RPADDLE_UP
			CMP AL, 4Fh ; O
			JE MOVE_RPADDLE_UP

			CMP AL, 6Ch ; l
			JE MOVE_RPADDLE_DOWN
			CMP AL, 4Ch ; L
			JE MOVE_RPADDLE_DOWN

			JMP EXIT_PADDLES_MOVEMENT

		CONTROL_BY_AI:
			; BALL_Y + BALL_SIZE < RIGHT_PADDLE_Y
			; ball is above the paddle
			MOV AX, BALL_Y
			ADD AX, BALL_SIZE
			CMP AX, RIGHT_PADDLE_Y
			JL MOVE_RPADDLE_UP

			; BALL_Y > RIGHT_PADDLE_Y + PADDLE_HEIGHT
			; ball is below the paddle
			MOV AX, RIGHT_PADDLE_Y
			ADD AX, PADDLE_HEIGHT
			CMP AX, BALL_Y
			JL MOVE_RPADDLE_DOWN

			JMP EXIT_PADDLES_MOVEMENT

		MOVE_LPADDLE_UP:
			MOV AX, PADDLE_VELOCITY
			SUB LEFT_PADDLE_Y, AX

			MOV AX, WINDOW_PADDING
			CMP LEFT_PADDLE_Y, AX
			JL FIX_LPADDLE_TOP

			JMP EXIT_PADDLES_MOVEMENT

			FIX_LPADDLE_TOP:
				MOV LEFT_PADDLE_Y, AX
				RET

		MOVE_LPADDLE_DOWN:
			MOV AX, PADDLE_VELOCITY
			ADD LEFT_PADDLE_Y, AX

			MOV AX, WINDOW_HEIGHT
			SUB AX, WINDOW_PADDING
			SUB AX, PADDLE_HEIGHT
			CMP LEFT_PADDLE_Y, AX
			JG FIX_LPADDLE_BOTTOM

			JMP EXIT_PADDLES_MOVEMENT

			FIX_LPADDLE_BOTTOM:
				MOV LEFT_PADDLE_Y, AX
				RET

		MOVE_RPADDLE_UP:
			MOV AX, PADDLE_VELOCITY
			SUB RIGHT_PADDLE_Y, AX

			MOV AX, WINDOW_PADDING
			CMP RIGHT_PADDLE_Y, AX
			JL FIX_RPADDLE_TOP

			JMP EXIT_PADDLES_MOVEMENT

			FIX_RPADDLE_TOP:
				MOV RIGHT_PADDLE_Y, AX
				RET

		MOVE_RPADDLE_DOWN:
			MOV AX, PADDLE_VELOCITY
			ADD RIGHT_PADDLE_Y, AX

			MOV AX, WINDOW_HEIGHT
			SUB AX, WINDOW_PADDING
			SUB AX, PADDLE_HEIGHT
			CMP RIGHT_PADDLE_Y, AX
			JG FIX_RPADDLE_BOTTOM

			JMP EXIT_PADDLES_MOVEMENT

			FIX_RPADDLE_BOTTOM:
				MOV RIGHT_PADDLE_Y, AX
				RET

		EXIT_PADDLES_MOVEMENT:
			RET
	MOVE_PADDLES ENDP

	DRAW_BALL PROC NEAR
		MOV CX, BALL_X
		MOV DX, BALL_Y

		DRAW_PIXEL:
			; draw pixel
			MOV AH, 0Ch
			MOV AL, 0Fh ; color
			MOV BH, 00h ; page number
			INT 10h

			INC CX ; x++

			; !(CX - BALL_X > BALL_SIZE)
			; keep printing this line
			MOV AX, CX
			SUB AX, BALL_X
			CMP AX, BALL_SIZE
			JNG DRAW_PIXEL

			MOV CX, BALL_X ; reset x
			INC DX				 ; y++

			; !(DX - BALL_Y > BALL_SIZE)
			; keep printing the next line
			MOV AX, DX
			SUB AX, BALL_Y
			CMP AX, BALL_SIZE
			JNG DRAW_PIXEL

		RET
	DRAW_BALL ENDP

	DRAW_PADDLES PROC NEAR
		MOV CX, LEFT_PADDLE_X
		MOV DX, LEFT_PADDLE_Y

		LPADDLE_DRAW_PIXEL:
			; draw pixel
			MOV AH, 0Ch
			MOV AL, 0Fh ; color
			MOV BH, 00h ; page number
			INT 10h

			INC CX ; x++

			; !(CX - PADDLE_X > PADDLE_WIDTH)
			; keep printing this line
			MOV AX, CX
			SUB AX, LEFT_PADDLE_X
			CMP AX, PADDLE_WIDTH
			JNG LPADDLE_DRAW_PIXEL

			MOV CX, LEFT_PADDLE_X ; reset x
			INC DX								; y++

			; !(DX - LEFT_PADDLE_Y > PADDLE_HEIGHT)
			; keep printing the next line
			MOV AX, DX
			SUB AX, LEFT_PADDLE_Y
			CMP AX, PADDLE_HEIGHT
			JNG LPADDLE_DRAW_PIXEL

		MOV CX, RIGHT_PADDLE_X
		MOV DX, RIGHT_PADDLE_Y

		RPADDLE_DRAW_PIXEL:
			; draw pixel
			MOV AH, 0Ch
			MOV AL, 0Fh ; color
			MOV BH, 00h ; page number
			INT 10h

			INC CX ; x++

			; !(CX - PADDLE_X > PADDLE_WIDTH)
			; keep printing this line
			MOV AX, CX
			SUB AX, RIGHT_PADDLE_X
			CMP AX, PADDLE_WIDTH
			JNG RPADDLE_DRAW_PIXEL

			MOV CX, RIGHT_PADDLE_X ; reset x
			INC DX								 ; y++

			; !(DX - PADDLE_Y > PADDLE_HEIGHT)
			; keep printing the next line
			MOV AX, DX
			SUB AX, RIGHT_PADDLE_Y
			CMP AX, PADDLE_HEIGHT
			JNG RPADDLE_DRAW_PIXEL

		RET
	DRAW_PADDLES ENDP

	DRAW_UI PROC NEAR
		; print left paddle points
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 04h ; row
		MOV DL, 06h ; column
		INT 10h

		MOV AH, 09h ; write string to STDOUT
		LEA DX, LEFT_PADDLE_TEXT_POINTS
		INT 21h

		; print right paddle points
		MOV AH, 02h
		MOV BH, 00h
		MOV DH, 04h
		MOV DL, 1Fh
		INT 10h

		MOV AH, 09h
		LEA DX, RIGHT_PADDLE_TEXT_POINTS
		INT 21h

		RET	
	draw_UI ENDP

	UPDATE_LPADDLE_POINTS_TEXT PROC NEAR
		XOR AX, AX
		MOV AL, LEFT_PADDLE_POINTS

		ADD AL, 30h
		MOV [LEFT_PADDLE_TEXT_POINTS], AL

		RET
	UPDATE_LPADDLE_POINTS_TEXT ENDP

	UPDATE_RPADDLE_POINTS_TEXT PROC NEAR
		XOR AX, AX
		MOV AL, RIGHT_PADDLE_POINTS

		ADD AL, 30h
		MOV [RIGHT_PADDLE_TEXT_POINTS], AL

		RET
	UPDATE_RPADDLE_POINTS_TEXT ENDP

	DRAW_GAME_OVER PROC NEAR
		CALL CLEAR_SCREEN

		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 04h ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, GAME_OVER_TITLE
		INT 21h

		; show the winner
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 06h ; row number
		MOV DL, 04h ; column number
		INT 10h

		CALL UPDATE_WINNER_TEXT

		MOV AH, 09h ; write string to STDOU
		LEA DX, GAME_OVER_WINNER
		INT 21h

		; Show the play again message
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 08h ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, GAME_OVER_PLAY_AGAIN
		INT 21h

		; Show exit to main menu message
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 0Ah ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, GAME_OVER_GO_MAIN_MENU
		INT 21h

		; wait for key press
		MOV AH, 00h
		INT 16h

		CMP AL, 'R'
		JE RESTART_GAME
		CMP AL, 'r'
		JE RESTART_GAME

		CMP AL, 'E'
		JE EXIT_TO_MAIN
		CMP AL, 'e'
		JE EXIT_TO_MAIN

		RET

		RESTART_GAME:
			MOV GAME_ACTIVE, 01h
			RET

		EXIT_TO_MAIN:
			MOV CURRENT_SCENE, 00h
			RET
	DRAW_GAME_OVER ENDP

	DRAW_MAIN_MENU PROC NEAR
		CALL CLEAR_SCREEN

		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 04h ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, MAIN_MENU_TITLE
		INT 21h

		; show single player option
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 06h ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, MAIN_MENU_SINGLEPLAYER
		INT 21h

		; show multiplayer option
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 08h ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, MAIN_MENU_MULTIPLAYER
		INT 21h

		; show the exit message
		MOV AH, 02h ; set cursor position
		MOV BH, 00h ; page number
		MOV DH, 0Ah ; row number
		MOV DL, 04h ; column number
		INT 10h

		MOV AH, 09h ; write string to STDOU
		LEA DX, MAIN_MENU_EXIT
		INT 21h

		; wait for key press
		WAIT_KEY_PRESS:
			MOV AH, 00h
			INT 16h

			CMP AL, 'S'
			JE START_SINGLEPLAYER
			CMP AL, 's'
			JE START_SINGLEPLAYER

			CMP AL, 'M'
			JE START_MULTIPLAYER
			CMP AL, 'm'
			JE START_MULTIPLAYER

			CMP AL, 'E'
			JE EXIT_GAME
			CMP AL, 'e'
			JE EXIT_GAME

			JMP WAIT_KEY_PRESS

		START_SINGLEPLAYER:
			MOV CURRENT_SCENE, 01h
			MOV GAME_ACTIVE, 01h
			MOV AI_CONTROLLED, 00h
			RET

		START_MULTIPLAYER:
			MOV CURRENT_SCENE, 01h
			MOV GAME_ACTIVE, 01h
			MOV AI_CONTROLLED, 01h
			RET

		EXIT_GAME:
			MOV EXITING_GAME, 01h
			RET
	DRAW_MAIN_MENU ENDP

	UPDATE_WINNER_TEXT PROC NEAR
		MOV AL, WINNER_INDEX
		ADD AL, 30h

		MOV [GAME_OVER_WINNER + 7], AL

		RET
	UPDATE_WINNER_TEXT ENDP

	CLEAR_SCREEN PROC NEAR
		MOV AX, 0A000h ; Set the video memory segment to 0A000h
		MOV ES, AX
		MOV DI, 0      ; ES:0 is the start of the framebuffer
		MOV CX, 7D00h  ; Store the total number of bytes required for mode 0Dh (320x200 at 16 colors)
		CLD
		XOR AX, AX
		REP STOSW      ; zero CX * 2 bytes at ES:DI

		RET
	CLEAR_SCREEN ENDP

	CONCLUDE_EXIT_GAME PROC NEAR
		MOV AH, 00h
		MOV AL, 02h ; set text mode
		INT 10h

		MOV AH, 4Ch ; end program
		INT 21h

		RET
	CONCLUDE_EXIT_GAME ENDP

CODE ENDS
END
